
# 💳 Payment Service API

REST API для обработки заказов и платежей с поддержкой атомарных операций, идемпотентности и устойчивости к высокой нагрузке.

Проект реализован в рамках тестового задания и демонстрирует подходы к построению **надёжного backend-сервиса** для работы с платежами.

---

## 🚀 Features

* Регистрация и аутентификация пользователей (JWT)
* Управление заказами
* Создание и подтверждение платежей
* Поддержка идемпотентных запросов
* Атомарная обработка платежей
* Защита от двойной оплаты
* Rate limiting
* Устойчивость к сбоям внешнего платёжного провайдера
* Подробное логирование бизнес-событий

---

## 🧱 Domain Model

### User

* `id`
* `first_name`
* `last_name`
* `email`
* `password_hash`
* `created_at`

### Order

* `id`
* `user_id`
* `amount`
* `currency`
* `status` (`Created`, `Paid`, `Cancelled`)
* `created_at`

### Payment

* `id`
* `order_id`
* `user_id`
* `amount`
* `status` (`Pending`, `Successful`, `Failed`)
* `idempotency_key`
* `created_at`

---

## 🔐 Authentication & Authorization

* Используется **JWT Bearer Authentication**
* Пароли хранятся в виде хэша (**BCrypt**)
* Все операции с заказами и платежами доступны **только авторизованным пользователям**
* Доступ к заказам и платежам проверяется по `user_id`

---

## 💼 Business Rules

* Оплатить можно **только заказ в статусе `Created`**
* После успешного платежа заказ **атомарно** переходит в статус `Paid`
* Для одного заказа может быть несколько попыток оплаты
* **Только один платёж может быть успешным**
* Повторная оплата оплаченного заказа невозможна

---

## 🔁 Idempotency

Для защиты от повторных запросов используется **Idempotency Key**:

* `IdempotencyKey` передаётся при создании платежа
* В базе данных установлен **UNIQUE индекс**
* Повторный запрос с тем же ключом возвращает уже созданный платёж
* Реализация безопасна при конкурентных запросах

---

## 🔒 Atomicity & Concurrency

Для предотвращения race condition и двойной оплаты используется:

* **Row-level locking (`SELECT … FOR UPDATE`)**
* **Транзакции базы данных**
* **Conditional update** заказа (`UPDATE … WHERE status = Created`)

Это гарантирует, что:

* только один платёж может изменить статус заказа
* при параллельных запросах double-spend невозможен

---

## 🚦 Rate Limiting

Для защиты от злоупотреблений используется **Fixed Window Rate Limiter**:

* 100 запросов в минуту на клиента
* При превышении лимита возвращается `429 Too Many Requests`

---

## 🔌 Resilience & External Dependencies

Взаимодействие с платёжным провайдером реализовано с учётом отказоустойчивости:

* `HttpClientFactory`
* **Polly Circuit Breaker**
* Быстрый отказ при недоступности провайдера
* Система не деградирует при сбоях внешних сервисов

---

## 💱 Currency Representation

В текущей реализации валюта хранится как строка и валидируется
по whitelist поддерживаемых значений.

```text
USD, EUR, RUB, TJS
```

Такой подход выбран намеренно для простоты решения.

В production-системе это может быть улучшено за счёт:

* использования enum,

---

## 📊 Logging

Реализовано структурированное логирование ключевых бизнес-событий:

* создание заказа
* создание платежа
* идемпотентные запросы
* подтверждение платежа
* ошибки доступа
* сбои платёжного провайдера
* успешные и неуспешные операции

Sensitive-данные (пароли, токены) **не логируются**.

---

## 🛠 Technology Stack

* **.NET / ASP.NET Core**
* **Entity Framework Core**
* **PostgreSQL**
* **JWT**
* **BCrypt**
* **Polly**
* **Rate Limiting Middleware**
* **Swagger**

---

## ▶️ Running the Project

1. Склонировать репозиторий
2. Настроить строку подключения к PostgreSQL
3. Заполнить `appsettings.json` (JWT, DB)
4. Применить миграции
5. Запустить приложение

```bash
dotnet run
```

Swagger будет доступен по адресу:

```
/swagger
```

---

## 🧠 Design Notes

* Проект ориентирован на читаемость и надёжность
* Бизнес-логика вынесена в сервисы
* EF Core конфигурации вынесены отдельно
* Ошибки возвращаются в унифицированном формате
* Архитектура легко расширяется (refresh tokens, webhooks, refunds)

---

## ✅ Conclusion

Данный проект демонстрирует:

* корректную работу с конкурентными платежами
* понимание транзакционной целостности
* умение проектировать idempotent API
* внимание к security и reliability
